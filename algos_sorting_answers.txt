>1.Write pseudocode for bubble sort.
 
```
FUNCTION bubbleSort(collection)
   REPEAT
     SET swapped to false
     FOR i = FIRST INDEX of collection to LAST INDEX of collection - 1
       IF collection[i] > collection[i + 1] THEN
         SET tmp to collection[i]
         SET collection[i] to collection[i + 1]
         SET collection[i + 1] to tmp
         SET swapped to true
       END IF
     END FOR
   UNTIL swapped is FALSE
   RETURN collection
END FUNCTION
```

>2.Write pseudocode for quicksort.

```
FUNCTION quickSort(collection)
  SET low to 0
  SET high to collection -1
    IF low < high THEN
        SET pivot to partition WITH collection, low ,high
        CALL quickSort WITH collection, low, pivot
        CALL quickSort WITH collection, pivot + 1, high
    END IF
END FUNCTION

FUNCTION partition(collection, low, high){
     SET pivot to collection[low]
     SET leftwall to low

     FOR each item in collection
         IF collection[i] < pivot THEN
             swap collection[i] with collection[leftwall + 1]
             SET leftwall to leftwall + 1
         END IF
     END FOR
     swap WITH pivot, collection[leftwall]

RETURN leftwall
```

>3.We talked about time complexity in a previous checkpoint, and how to get an idea of the efficiency of an algorithm. 
After looking at the pseudocode for the above sorting methods, identify why merge sort and quick sort are much more 
efficient than the others. Walking through each algorithm with a few sample collections may help.

A: Merge sort is efficient because it can handle large collections but it doesn't interate through every item. It breaks everything up into sub-collections then merges them back together.

Quick sort is efficient because it can handle large collections using less memory and the divide and conquer method, so it doesn't interate over every item.   

>4.All of the sorts addressed in this checkpoint are known as comparison sorts. Research bucket sort and explain how it works. What is the ideal input for bucket sort?

A: Bucket sort starts with an unsorted array. Set up an array of empty buckets and we place our input into the buckets depending on the inputs range. Sort the items in the bucket, and place back in original array
 

